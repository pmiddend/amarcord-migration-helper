{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Applicative ((<|>))
import Control.Lens (ix, traversed, (^.), (^..), (^?))
import Data.Aeson.Lens
import qualified Data.Attoparsec.ByteString as Atto
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as BSL
import Data.List (singleton)
import qualified Data.Map.Strict as Map
import Data.Maybe (fromMaybe, listToMaybe)
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TLE
import Network.HTTP.Client
import Text.Regex

retrieveExternalToInternalIdMap :: Int -> IO (Map.Map Integer Integer)
retrieveExternalToInternalIdMap beamtimeInternalId = do
  let settings = managerSetProxy (proxyEnvironment Nothing) defaultManagerSettings
  man <- newManager settings
  let reqUrl = "http://cfeld-web02:6020/api/runs/113"
  req <- parseRequest reqUrl
  putStrLn ("making request " <> show reqUrl)
  response <- httpLbs req man
  let runObjects = responseBody response ^.. key "runs" . _Array . traversed . _Object
      externalToInternalId :: Map.Map Integer Integer
      externalToInternalId = Map.fromList (runObjects >>= (\runObject -> maybe [] singleton ((,) <$> (runObject ^? ix "external_id" . _Integer) <*> (runObject ^? ix "id" . _Integer))))
  pure externalToInternalId

-- data StreamLine
--   = CrystFELVersion BS.ByteString
--   | Indexamajig BS.ByteString
--   | BeginChunk
--   | Other

-- streamLineParser :: Atto.Parser StreamLine
-- streamLineParser =
--   CrystFELVersion <$> (Atto.string "Generated by CrystFEL" *> Atto.takeWhile (\c -> c /= 0x0a))
--     <|> (Indexamajig <$> (Atto.string "/asap3" *> Atto.takeWhile (\c -> c /= 0x0a)))
--     <|> (BeginChunk <$ Atto.string "----- Begin chunk -----\n")
--     <|> (Other <$ Atto.takeWhile (\c -> c /= 0x0a))
--
-- streamFileParser :: Atto.Parser [StreamLine]
-- streamFileParser = streamLineParser `Atto.sepBy` Atto.satisfy (== 0x0a)
polishCommandLine :: TL.Text -> TL.Text
polishCommandLine cli =
  let (_, actualCli) = TL.breakOn "indexamajig" cli
      regexReplace :: Regex -> TL.Text -> TL.Text -> TL.Text
      regexReplace needle haystack replacement = TL.pack (subRegex needle (TL.unpack haystack) (TL.unpack replacement))
      regexRemove :: Regex -> TL.Text -> TL.Text
      regexRemove needle haystack = regexReplace needle haystack ""
      regexRemovals =
        mkRegex
          <$> [ "--asapo-[^ =]*[ =][^ ]*",
                "-j [0-9]+",
                "--data-format=[^ ]+",
                "-p [^ ]+",
                "-g [^ ]+",
                "--profile",
                "-o [^ ]+",
                "indexamajig"
              ]
      afterRemovals = foldr regexRemove actualCli regexRemovals
   in TL.strip (regexReplace (mkRegex "[ ]+") afterRemovals " ")

extractGeometryFromCommandLine :: TL.Text -> Maybe TL.Text
extractGeometryFromCommandLine cli =
  case matchRegex (mkRegex "-g ([^ ]+)") (TL.unpack cli) of
    Nothing -> Nothing
    Just (geometry : _) -> Just (TL.pack geometry)

main :: IO ()
main = do
  putStrLn "reading file..."
  fileContents <- BSL.readFile "/asap3/petra3/gpfs/p11/2022/data/11015430/processed/streams/run_120_indexing_109.stream"
  let fileDecoded = TLE.decodeUtf8 fileContents
      fileLines = TL.lines fileDecoded
      crystfelVersionLine = listToMaybe (filter (\line -> "Generated by CrystFEL" `TL.isPrefixOf` line) fileLines)
      indexamajigLine = listToMaybe (filter (\line -> "indexamajig" `TL.isInfixOf` line) fileLines)
      numberOfImages = length (filter (\line -> "----- Begin chunk" `TL.isPrefixOf` line) fileLines)
      numberOfHits = length (filter (\line -> "hit = 1" `TL.isPrefixOf` line) fileLines)
  print crystfelVersionLine
  print numberOfImages
  print numberOfHits
  print (maybe "" polishCommandLine indexamajigLine)
  print (fromMaybe "" (indexamajigLine >>= extractGeometryFromCommandLine))

-- print numberOfImages
