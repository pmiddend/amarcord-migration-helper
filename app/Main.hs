{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections #-}

module Main where

import Conduit
import Control.Applicative ((<|>))
import Control.Lens (ix, traversed, (^.), (^..), (^?))
import Control.Monad (forM_, mapM)
import qualified Crypto.Hash as Crypto
import Crypto.Hash.Algorithms (SHA256)
import Data.Aeson.Lens
import qualified Data.Attoparsec.ByteString as Atto
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as BSL
import Data.Either (partitionEithers)
import Data.List (singleton)
import qualified Data.List.NonEmpty as NE
import qualified Data.Map.Strict as Map
import Data.Maybe (fromMaybe, listToMaybe, mapMaybe)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.Text.IO as TIO
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TLE
import Network.HTTP.Client
import System.Directory (listDirectory)
import System.FilePath ((</>))
import Text.Read (readMaybe)
import Text.Regex

type ExternalRunId = Integer

type InternalRunId = Integer

retrieveExternalToInternalIdMap :: Int -> IO (Map.Map ExternalRunId Integer)
retrieveExternalToInternalIdMap beamtimeInternalId = do
  let settings = managerSetProxy (proxyEnvironment Nothing) defaultManagerSettings
  man <- newManager settings
  let reqUrl = "http://cfeld-web02:6020/api/runs/113"
  req <- parseRequest reqUrl
  putStrLn ("making request " <> show reqUrl)
  response <- httpLbs req man
  let runObjects = responseBody response ^.. key "runs" . _Array . traversed . _Object
      externalToInternalId :: Map.Map Integer Integer
      externalToInternalId = Map.fromList (runObjects >>= (\runObject -> maybe [] singleton ((,) <$> (runObject ^? ix "external_id" . _Integer) <*> (runObject ^? ix "id" . _Integer))))
  pure externalToInternalId

polishCommandLine :: T.Text -> T.Text
polishCommandLine cli =
  let (_, actualCli) = T.breakOn "indexamajig" cli
      regexReplace :: Regex -> T.Text -> T.Text -> T.Text
      regexReplace needle haystack replacement = T.pack (subRegex needle (T.unpack haystack) (T.unpack replacement))
      regexRemove :: Regex -> T.Text -> T.Text
      regexRemove needle haystack = regexReplace needle haystack ""
      regexRemovals =
        mkRegex
          <$> [ "--asapo-[^ =]*[ =][^ ]*",
                "-j [0-9]+",
                "--data-format=[^ ]+",
                "-p [^ ]+",
                "-g [^ ]+",
                "--profile",
                "-o [^ ]+",
                "indexamajig"
              ]
      afterRemovals = foldr regexRemove actualCli regexRemovals
   in T.strip (regexReplace (mkRegex "[ ]+") afterRemovals " ")

extractGeometryFromCommandLine :: T.Text -> Maybe T.Text
extractGeometryFromCommandLine cli =
  case matchRegex (mkRegex "-g ([^ ]+)") (T.unpack cli) of
    Nothing -> Nothing
    Just (geometry : _) -> Just (T.pack geometry)

data StreamFileDirectInformation = StreamFileDirectInformation
  { rawCrystfelVersion :: Maybe T.Text,
    rawCommandLine :: Maybe T.Text,
    rawFoms :: (Int, Int, Int)
  }
  deriving (Show)

data StreamFileInformation = StreamFileInformation
  { streamFileCrystfelVersion :: T.Text,
    streamFileCommandLine :: T.Text,
    streamFileGeometry :: T.Text,
    streamFileGeometryHash :: T.Text,
    streamFileFoms :: (Int, Int, Int)
  }
  deriving (Show)

versionPrefix = "Generated by CrystFEL"

extractVersion = T.drop (BS.length "Generated by CrystFEL" + 1)

conduitForStreamDirectInformation = do
  dropWhileC (\line -> not (versionPrefix `BS.isPrefixOf` line))
  generatedByCrystFel <- headC
  dropWhileC (\line -> not ("indexamajig" `BS.isInfixOf` line))
  indexamajig <- headC
  imagesAndHits <-
    getZipSink
      ( (,,)
          <$> ZipSink (lengthIfC (\line -> line == "----- Begin chunk -----"))
          <*> ZipSink (lengthIfC (\line -> line == "hit = 1"))
          <*> ZipSink (lengthIfC (\line -> "indexed_by = a" `BS.isPrefixOf` line))
      )
  pure
    ( StreamFileDirectInformation
        (TE.decodeUtf8 <$> generatedByCrystFel)
        (TE.decodeUtf8 <$> indexamajig)
        imagesAndHits
    )

extractStreamFileDirectInformation :: FilePath -> IO StreamFileDirectInformation
extractStreamFileDirectInformation fileName =
  runConduitRes $
    sourceFile fileName
      .| linesUnboundedAsciiC
      .| conduitForStreamDirectInformation

extractStreamFileInformation :: FilePath -> IO (Either T.Text StreamFileInformation)
extractStreamFileInformation fileName = do
  output <- extractStreamFileDirectInformation fileName
  case rawCommandLine output of
    Nothing -> pure (Left "couldn't parse command line out of stream file")
    Just commandLine' ->
      case rawCrystfelVersion output of
        Nothing -> pure (Left "couldn't parse CrystFEL version out of stream file")
        Just crystfelVersion -> do
          case extractGeometryFromCommandLine commandLine' of
            Nothing -> pure (Left "couldn't extract geometry file from command line")
            Just geometryFile' -> do
              geometryFileContents <- BS.readFile (T.unpack geometryFile')
              let geometryHash = sha256HashAsText geometryFileContents
              pure $
                Right $
                  StreamFileInformation
                    (extractVersion crystfelVersion)
                    (polishCommandLine commandLine')
                    geometryFile'
                    geometryHash
                    (rawFoms output)

sha256HashAsText :: BS.ByteString -> T.Text
sha256HashAsText bs = T.pack (show (Crypto.hash bs :: Crypto.Digest SHA256))

retrieveStreamFiles :: FilePath -> IO [(FilePath, ExternalRunId)]
retrieveStreamFiles baseDir = do
  files <- listDirectory baseDir
  let parsePath :: FilePath -> Maybe (FilePath, ExternalRunId)
      parsePath fp = (fp,) <$> (matchRegex (mkRegex "run_([0-9]+).*\\.stream") fp >>= listToMaybe >>= readMaybe)
  pure (mapMaybe parsePath files)

processBeamTimeStream externalToInternalRunId baseDir (streamFileName, externalRunId) = do
  let streamFile = baseDir </> streamFileName
  TIO.putStrLn $ "reading data for run " <> T.pack (show externalRunId)
  case Map.lookup externalRunId externalToInternalRunId of
    Nothing -> pure $ Left $ "couldn't find internal run ID for run " <> T.pack (show externalRunId)
    Just internalRunId -> do
      output <- extractStreamFileInformation streamFile
      case output of
        Left e -> pure $ Left $ "error reading stream file " <> T.pack streamFile <> ": " <> e
        Right v -> pure $ Right $ (internalRunId, v)

printParams :: StreamFileInformation -> T.Text
printParams params = "\"crystfel_version\": \"" <> streamFileCrystfelVersion params <> "\""

printRange :: (Integer, Integer) -> T.Text
printRange (from, to) = "(" <> T.pack (show from) <> ", " <> T.pack (show to) <> ")"

printRunsWithParameters runRanges parameters = "{" <> "\"run_ranges\": [" <> T.intercalate "," (printRange <$> runRanges) <> "], " <> printParams parameters <> "}"

foldIntervals :: NE.NonEmpty Integer -> [(Integer, Integer)]
foldIntervals list@(x NE.:| xs) =
  let (pairs, lastPair) = foldl f ([], (x, x)) list
   in lastPair : pairs
  where
    f :: ([(Integer, Integer)], (Integer, Integer)) -> Integer -> ([(Integer, Integer)], (Integer, Integer))
    f (oldPairs, (startSequence, endSequence)) newNumber =
      if newNumber == endSequence
        then (oldPairs, (startSequence, endSequence))
        else
          if newNumber == endSequence + 1
            then (oldPairs, (startSequence, endSequence + 1))
            else ((startSequence, endSequence) : oldPairs, (newNumber, newNumber))

migrate113 = do
  externalToInternalRunId <- retrieveExternalToInternalIdMap 113
  let baseDir = "/asap3/petra3/gpfs/p11/2022/data/11015430/processed/streams/"
  streamFiles <- retrieveStreamFiles baseDir
  infos <- mapM (\streamFile -> processBeamTimeStream externalToInternalRunId baseDir streamFile) streamFiles
  let (errors, infos') = partitionEithers infos
      groups :: [NE.NonEmpty (InternalRunId, StreamFileInformation)]
      groups =
        NE.groupAllWith
          (\(_, info) -> (streamFileCrystfelVersion info, streamFileCommandLine info, streamFileGeometry info))
          infos'
      mapGroup :: NE.NonEmpty (InternalRunId, StreamFileInformation) -> T.Text
      mapGroup g =
        let runRanges :: [(Integer, Integer)]
            runRanges = foldIntervals (NE.sort (fst <$> g))
            parameters = snd (NE.head g)
         in printRunsWithParameters runRanges parameters

  forM_ (mapGroup <$> groups) \stream -> TIO.putStrLn stream

-- forM_ infos \x -> case x of
--   Left e -> TIO.putStrLn $ "error " <> e
--   Right (_, i, _) -> TIO.putStrLn (T.pack (show i))

-- withTaskGroup 4 \g -> do
-- forM_ streamFiles \(streamFileName, externalRunId) -> do
--   let streamFile = baseDir </> streamFileName
--   TIO.putStrLn $ "reading data for run " <> T.pack (show externalRunId)
--   case Map.lookup externalRunId externalToInternalRunId of
--     Nothing -> TIO.putStrLn $ "couldn't find internal run ID for run " <> T.pack (show externalRunId)
--     Just internalRunId -> do
--       output <- extractInformationFromStreamFile streamFile
--       case output of
--         Left e -> TIO.putStrLn $ "error reading stream file " <> T.pack streamFile <> ": " <> e
--         Right v -> TIO.putStrLn $ T.pack $ show v

-- putStrLn "reading file..."
-- output <- extractInformationFromStreamFile inputStreamFile
-- case output of
--   Left e -> error (T.unpack e)
--   Right v -> print v

-- case streamFileCommandLine output of
--   Nothing -> error "couldn't parse command line out of stream file"
--   Just commandLine' ->
--     case streamFileCrystfelVersion output of
--       Nothing -> error "couldn't parse CrystFEL version out of stream file"
--       Just crystfelVersion -> do
--         TIO.putStrLn (polishCommandLine commandLine')
--         TIO.putStrLn (T.pack (show (extractGeometryFromCommandLine commandLine')))
--         TIO.putStrLn (extractVersion crystfelVersion)

-- mainWithoutConduit :: IO ()
-- mainWithoutConduit = do
--   putStrLn "reading file..."
--   fileContents <- BSL.readFile inputStreamFile
--   let fileDecoded = TLE.decodeUtf8 fileContents
--       fileLines = TL.lines fileDecoded
--       crystfelVersionLine = listToMaybe (filter (\line -> "Generated by CrystFEL" `TL.isPrefixOf` line) fileLines)
--       indexamajigLine = listToMaybe (filter (\line -> "indexamajig" `TL.isInfixOf` line) fileLines)
--       numberOfImages = length (filter (\line -> "----- Begin chunk" `TL.isPrefixOf` line) fileLines)
--       numberOfHits = length (filter (\line -> "hit = 1" `TL.isPrefixOf` line) fileLines)
--   print crystfelVersionLine
--   print numberOfImages
--   print numberOfHits

--   print (maybe "" polishCommandLine indexamajigLine)
--   print (fromMaybe "" (indexamajigLine >>= extractGeometryFromCommandLine))
